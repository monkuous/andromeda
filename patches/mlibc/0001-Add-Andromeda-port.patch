From 5b2d971ecf1bc5e9b68e46ebbb1997146ff92161 Mon Sep 17 00:00:00 2001
From: monkuous <84319635+monkuous@users.noreply.github.com>
Date: Sun, 2 Mar 2025 22:07:04 +0100
Subject: [PATCH] Add Andromeda port

---
 meson.build                                   |  18 +-
 options/ansi/generic/stdio.cpp                |   4 +-
 options/ansi/include/bits/ansi/time_t.h       |   4 +-
 options/elf/include/elf.h                     |   1 +
 options/internal/include/bits/off_t.h         |   6 +-
 options/internal/x86/setjmp.S                 |  12 +-
 options/posix/include/mlibc/posix-sysdeps.hpp |   2 +-
 options/rtld/generic/linker.cpp               |  11 +
 options/rtld/x86/elf.hpp                      |   1 +
 sysdeps/andromeda/crt/Scrt0.S                 |  27 +
 sysdeps/andromeda/crt/crt0.S                  |  24 +
 sysdeps/andromeda/crt/crti.S                  |  20 +
 sysdeps/andromeda/crt/crtn.S                  |  12 +
 sysdeps/andromeda/crt/meson.build             |  13 +
 sysdeps/andromeda/generic/entry.cpp           |  17 +
 sysdeps/andromeda/generic/generic.cpp         | 823 ++++++++++++++++++
 sysdeps/andromeda/generic/meson.build         |   2 +
 sysdeps/andromeda/generic/mntent.cpp          | 164 ++++
 sysdeps/andromeda/generic/mount.cpp           |  36 +
 sysdeps/andromeda/generic/syscall.h           |  78 ++
 sysdeps/andromeda/include/abi-bits/access.h   |   1 +
 sysdeps/andromeda/include/abi-bits/auxv.h     |   1 +
 sysdeps/andromeda/include/abi-bits/blkcnt_t.h |   1 +
 .../andromeda/include/abi-bits/blksize_t.h    |   1 +
 .../andromeda/include/abi-bits/clockid_t.h    |   1 +
 sysdeps/andromeda/include/abi-bits/dev_t.h    |   1 +
 sysdeps/andromeda/include/abi-bits/epoll.h    |  12 +
 sysdeps/andromeda/include/abi-bits/errno.h    |   1 +
 sysdeps/andromeda/include/abi-bits/fcntl.h    |   1 +
 .../andromeda/include/abi-bits/fsblkcnt_t.h   |   1 +
 .../andromeda/include/abi-bits/fsfilcnt_t.h   |   1 +
 sysdeps/andromeda/include/abi-bits/gid_t.h    |   1 +
 sysdeps/andromeda/include/abi-bits/in.h       |   1 +
 sysdeps/andromeda/include/abi-bits/ino_t.h    |   1 +
 sysdeps/andromeda/include/abi-bits/inotify.h  |   1 +
 sysdeps/andromeda/include/abi-bits/ioctls.h   |   1 +
 sysdeps/andromeda/include/abi-bits/ipc.h      |   1 +
 sysdeps/andromeda/include/abi-bits/limits.h   |   1 +
 sysdeps/andromeda/include/abi-bits/mode_t.h   |   1 +
 sysdeps/andromeda/include/abi-bits/mqueue.h   |   1 +
 sysdeps/andromeda/include/abi-bits/msg.h      |   1 +
 sysdeps/andromeda/include/abi-bits/nlink_t.h  |   1 +
 sysdeps/andromeda/include/abi-bits/packet.h   |   1 +
 sysdeps/andromeda/include/abi-bits/pid_t.h    |   1 +
 sysdeps/andromeda/include/abi-bits/poll.h     |   1 +
 sysdeps/andromeda/include/abi-bits/ptrace.h   |   1 +
 sysdeps/andromeda/include/abi-bits/random.h   |   1 +
 sysdeps/andromeda/include/abi-bits/reboot.h   |   1 +
 sysdeps/andromeda/include/abi-bits/resource.h |   1 +
 sysdeps/andromeda/include/abi-bits/rlim_t.h   |   1 +
 .../andromeda/include/abi-bits/seek-whence.h  |   1 +
 sysdeps/andromeda/include/abi-bits/shm.h      |   1 +
 sysdeps/andromeda/include/abi-bits/sigevent.h |   1 +
 sysdeps/andromeda/include/abi-bits/signal.h   | 537 ++++++++++++
 sysdeps/andromeda/include/abi-bits/sigval.h   |   1 +
 sysdeps/andromeda/include/abi-bits/socket.h   |   1 +
 .../andromeda/include/abi-bits/socklen_t.h    |   1 +
 sysdeps/andromeda/include/abi-bits/stat.h     |   1 +
 sysdeps/andromeda/include/abi-bits/statfs.h   |   1 +
 sysdeps/andromeda/include/abi-bits/statvfs.h  |  48 +
 sysdeps/andromeda/include/abi-bits/statx.h    |   1 +
 .../andromeda/include/abi-bits/suseconds_t.h  |   1 +
 sysdeps/andromeda/include/abi-bits/termios.h  |   1 +
 sysdeps/andromeda/include/abi-bits/time.h     |   1 +
 sysdeps/andromeda/include/abi-bits/uid_t.h    |   1 +
 sysdeps/andromeda/include/abi-bits/utsname.h  |   1 +
 sysdeps/andromeda/include/abi-bits/vm-flags.h |   1 +
 sysdeps/andromeda/include/abi-bits/vt.h       |   1 +
 sysdeps/andromeda/include/abi-bits/wait.h     |   1 +
 sysdeps/andromeda/include/abi-bits/xattr.h    |   1 +
 sysdeps/andromeda/include/andromeda/cpu.h     |  35 +
 sysdeps/andromeda/include/andromeda/ioctl.h   |  19 +
 sysdeps/andromeda/include/andromeda/memory.h  |  16 +
 sysdeps/andromeda/include/andromeda/mount.h   |  15 +
 sysdeps/andromeda/include/andromeda/string.h  |  11 +
 sysdeps/andromeda/include/andromeda/syscall.h |  91 ++
 sysdeps/andromeda/include/andromeda/video.h   |  51 ++
 sysdeps/andromeda/include/meson.build         |  65 ++
 sysdeps/andromeda/include/mntent.h            |  43 +
 sysdeps/andromeda/include/sys/sysmacros.h     |  33 +
 sysdeps/andromeda/meson.build                 |  13 +
 81 files changed, 2297 insertions(+), 14 deletions(-)
 create mode 100644 sysdeps/andromeda/crt/Scrt0.S
 create mode 100644 sysdeps/andromeda/crt/crt0.S
 create mode 100644 sysdeps/andromeda/crt/crti.S
 create mode 100644 sysdeps/andromeda/crt/crtn.S
 create mode 100644 sysdeps/andromeda/crt/meson.build
 create mode 100644 sysdeps/andromeda/generic/entry.cpp
 create mode 100644 sysdeps/andromeda/generic/generic.cpp
 create mode 100644 sysdeps/andromeda/generic/meson.build
 create mode 100644 sysdeps/andromeda/generic/mntent.cpp
 create mode 100644 sysdeps/andromeda/generic/mount.cpp
 create mode 100644 sysdeps/andromeda/generic/syscall.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/access.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/auxv.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/blkcnt_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/blksize_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/clockid_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/dev_t.h
 create mode 100644 sysdeps/andromeda/include/abi-bits/epoll.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/errno.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/fcntl.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/fsblkcnt_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/fsfilcnt_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/gid_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/in.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/ino_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/inotify.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/ioctls.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/ipc.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/limits.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/mode_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/mqueue.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/msg.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/nlink_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/packet.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/pid_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/poll.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/ptrace.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/random.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/reboot.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/resource.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/rlim_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/seek-whence.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/shm.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/sigevent.h
 create mode 100644 sysdeps/andromeda/include/abi-bits/signal.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/sigval.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/socket.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/socklen_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/stat.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/statfs.h
 create mode 100644 sysdeps/andromeda/include/abi-bits/statvfs.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/statx.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/suseconds_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/termios.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/time.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/uid_t.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/utsname.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/vm-flags.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/vt.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/wait.h
 create mode 120000 sysdeps/andromeda/include/abi-bits/xattr.h
 create mode 100644 sysdeps/andromeda/include/andromeda/cpu.h
 create mode 100644 sysdeps/andromeda/include/andromeda/ioctl.h
 create mode 100644 sysdeps/andromeda/include/andromeda/memory.h
 create mode 100644 sysdeps/andromeda/include/andromeda/mount.h
 create mode 100644 sysdeps/andromeda/include/andromeda/string.h
 create mode 100644 sysdeps/andromeda/include/andromeda/syscall.h
 create mode 100644 sysdeps/andromeda/include/andromeda/video.h
 create mode 100644 sysdeps/andromeda/include/meson.build
 create mode 100644 sysdeps/andromeda/include/mntent.h
 create mode 100644 sysdeps/andromeda/include/sys/sysmacros.h
 create mode 100644 sysdeps/andromeda/meson.build

diff --git a/meson.build b/meson.build
index a1e526bc..20ef22ad 100644
--- a/meson.build
+++ b/meson.build
@@ -17,6 +17,8 @@ libc_include_dirs = [
 	include_directories('options/internal' / host_machine.cpu_family() + '-include')
 ]
 
+compiler_include_dirs = [ ]
+
 rtld_sources = [ ]
 rtld_dso_sources = [ ]
 libc_sources = [ ]
@@ -104,12 +106,10 @@ if not headers_only
 		endif
 
 		if c_compiler.get_id() == 'gcc' and fs.exists(ccdir / 'include-fixed')
-			rtld_include_dirs += include_directories(ccdir / 'include-fixed')
-			libc_include_dirs += include_directories(ccdir / 'include-fixed')
+			compiler_include_dirs += include_directories(ccdir / 'include-fixed')
 		endif
 
-		rtld_include_dirs += include_directories(ccdir / 'include')
-		libc_include_dirs += include_directories(ccdir / 'include')
+		compiler_include_dirs += include_directories(ccdir / 'include')
 	endif
 
 	if not freestnd_cxx_hdrs_dep.found()
@@ -160,8 +160,7 @@ if not headers_only
 			endif
 		endforeach
 
-		rtld_include_dirs += cplusplus_include_path
-		libc_include_dirs += cplusplus_include_path
+		compiler_include_dirs += cplusplus_include_path
 	endif
 endif
 
@@ -272,6 +271,10 @@ elif host_machine.system() == 'nyaux'
 	rtld_include_dirs += include_directories('sysdeps/nyaux/include')
 	libc_include_dirs += include_directories('sysdeps/nyaux/include')
 	subdir('sysdeps/nyaux')
+elif host_machine.system() == 'andromeda'
+	internal_conf.set10('MLIBC_MAP_DSO_SEGMENTS', true)
+	internal_conf.set10('MLIBC_MMAP_ALLOCATE_DSO', true)
+	subdir('sysdeps/andromeda')
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
@@ -357,6 +360,9 @@ libc_include_dirs += include_directories('.')
 
 #----------------------------------------------------------------------------------------
 
+rtld_include_dirs += compiler_include_dirs
+libc_include_dirs += compiler_include_dirs
+
 configure_file(input: 'internal-config.h.in',
 	output: 'internal-config.h',
 	configuration: internal_conf)
diff --git a/options/ansi/generic/stdio.cpp b/options/ansi/generic/stdio.cpp
index 2dd7cfb4..d3d45cec 100644
--- a/options/ansi/generic/stdio.cpp
+++ b/options/ansi/generic/stdio.cpp
@@ -392,7 +392,8 @@ static int do_scanf(H &handler, const char *fmt, __builtin_va_list args) {
 			} else {
 				char *typed_dest = (char *)dest;
 				if(typed_dest)
-					typed_dest[count++] = c;
+					typed_dest[count] = c;
+				count++;
 			}
 		};
 
@@ -647,7 +648,6 @@ static int do_scanf(H &handler, const char *fmt, __builtin_va_list args) {
 					handler.consume();
 					append_to_buffer(c);
 					c = handler.look_ahead();
-					count++;
 				}
 				break;
 			}
diff --git a/options/ansi/include/bits/ansi/time_t.h b/options/ansi/include/bits/ansi/time_t.h
index 1c29fa0f..88600a8e 100644
--- a/options/ansi/include/bits/ansi/time_t.h
+++ b/options/ansi/include/bits/ansi/time_t.h
@@ -2,7 +2,9 @@
 #ifndef MLIBC_TIME_T
 #define MLIBC_TIME_T
 
-typedef long time_t;
+#include <bits/types.h>
+
+typedef __mlibc_int64 time_t;
 
 #endif
 
diff --git a/options/elf/include/elf.h b/options/elf/include/elf.h
index 9eabfc60..2ff10b35 100644
--- a/options/elf/include/elf.h
+++ b/options/elf/include/elf.h
@@ -269,6 +269,7 @@ enum {
 	R_386_TLS_TPOFF = 14,
 	R_386_TLS_DTPMOD32 = 35,
 	R_386_TLS_DTPOFF32 = 36,
+	R_386_TLS_TPOFF32 = 37,
 	R_386_TLS_DESC = 41,
 	R_386_IRELATIVE = 42
 };
diff --git a/options/internal/include/bits/off_t.h b/options/internal/include/bits/off_t.h
index 43dcd9ed..277c5b78 100644
--- a/options/internal/include/bits/off_t.h
+++ b/options/internal/include/bits/off_t.h
@@ -1,8 +1,10 @@
 #ifndef MLIBC_OFF_T_H
 #define MLIBC_OFF_T_H
 
+#include <bits/types.h>
+
 /* TODO: use something like int64_t instead? */
-typedef long off_t;
-typedef long off64_t;
+typedef __mlibc_int64 off_t;
+typedef __mlibc_int64 off64_t;
 
 #endif /* MLIBC_OFF_T_H */
diff --git a/options/internal/x86/setjmp.S b/options/internal/x86/setjmp.S
index d2cd348b..a049f8a7 100644
--- a/options/internal/x86/setjmp.S
+++ b/options/internal/x86/setjmp.S
@@ -17,8 +17,16 @@ __setjmp:
 	xor %eax, %eax
 	ret
 
-1:
-	jmp __sigsetjmp@PLT
+1:	push %ebx
+	call 1f
+1:	pop %ebx
+	add $(_GLOBAL_OFFSET_TABLE_ - 1b), %ebx
+	sub $4, %esp
+	pushl 12(%esp)
+	call __sigsetjmp@PLT
+	add $8, %esp
+	pop %ebx
+	ret
 
 .global setjmp
 .type setjmp, "function"
diff --git a/options/posix/include/mlibc/posix-sysdeps.hpp b/options/posix/include/mlibc/posix-sysdeps.hpp
index b23436b1..66cb6123 100644
--- a/options/posix/include/mlibc/posix-sysdeps.hpp
+++ b/options/posix/include/mlibc/posix-sysdeps.hpp
@@ -72,7 +72,7 @@ int sys_close(int fd);
 [[gnu::weak]] int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length);
 [[gnu::weak]] int sys_readlinkat(int dirfd, const char *path, void *buffer, size_t max_size, ssize_t *length);
 [[gnu::weak]] int sys_rmdir(const char *path);
-[[gnu::weak]] int sys_ftruncate(int fd, size_t size);
+[[gnu::weak]] int sys_ftruncate(int fd, off_t size);
 [[gnu::weak]] int sys_fallocate(int fd, off_t offset, size_t size);
 [[gnu::weak]] int sys_unlinkat(int fd, const char *path, int flags);
 [[gnu::weak]] int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd);
diff --git a/options/rtld/generic/linker.cpp b/options/rtld/generic/linker.cpp
index 33cd1b93..1a8a0c9f 100644
--- a/options/rtld/generic/linker.cpp
+++ b/options/rtld/generic/linker.cpp
@@ -1950,6 +1950,9 @@ void Loader::_processRelocations(Relocation &rel) {
 		__ensure(p);
 		rel.relocate(p->symbol()->st_value + rel.addend_rel() - TLS_DTV_OFFSET);
 	} break;
+#ifdef R_TLS_TPRELPOS
+	case R_TLS_TPRELPOS:
+#endif
 	case R_TLS_TPREL: {
 		uintptr_t off = rel.addend_rel();
 		ssize_t tls_offset = 0;
@@ -1974,6 +1977,14 @@ void Loader::_processRelocations(Relocation &rel) {
 			tls_offset = rel.object()->tlsOffset;
 		}
 
+#ifdef R_TLS_TPRELPOS
+		if (rel.type() == R_TLS_TPRELPOS) {
+			off = (tls_offset + tlsOffsetFromTp) - off;
+			rel.relocate(off);
+			break;
+		}
+#endif
+
 		off += tls_offset + tlsOffsetFromTp;
 		rel.relocate(off);
 	} break;
diff --git a/options/rtld/x86/elf.hpp b/options/rtld/x86/elf.hpp
index 0dc12ac8..7ec0e84f 100644
--- a/options/rtld/x86/elf.hpp
+++ b/options/rtld/x86/elf.hpp
@@ -39,5 +39,6 @@ using elf_vernaux = Elf32_Vernaux;
 #define R_TLS_DTPREL R_386_TLS_DTPOFF32
 #define R_TLS_TPREL R_386_TLS_TPOFF
 #define R_TLSDESC R_386_TLS_DESC
+#define R_TLS_TPRELPOS R_386_TLS_TPOFF32
 
 #define TP_TCB_OFFSET 0
diff --git a/sysdeps/andromeda/crt/Scrt0.S b/sysdeps/andromeda/crt/Scrt0.S
new file mode 100644
index 00000000..a979b033
--- /dev/null
+++ b/sysdeps/andromeda/crt/Scrt0.S
@@ -0,0 +1,27 @@
+.text
+
+.balign 16
+.globl _start
+.hidden _start
+.type _start, @function
+_start:
+	.cfi_startproc
+	.cfi_undefined eip
+
+	xor %ebp, %ebp
+	mov %esp, %eax
+
+    call 1f
+1:  pop %ebx
+    add $(_GLOBAL_OFFSET_TABLE_ - 1b), %ebx
+
+	sub $8, %esp
+	pushl %eax
+	pushl main@GOT(%ebx)
+	call __mlibc_entry
+	ud2
+
+	.cfi_endproc
+.size _start, . - _start
+
+.section .note.GNU-stack,"",@progbits
diff --git a/sysdeps/andromeda/crt/crt0.S b/sysdeps/andromeda/crt/crt0.S
new file mode 100644
index 00000000..9565ff03
--- /dev/null
+++ b/sysdeps/andromeda/crt/crt0.S
@@ -0,0 +1,24 @@
+.text
+
+.balign 16
+.globl _start
+.hidden _start
+.type _start, @function
+_start:
+	.cfi_startproc
+	.cfi_undefined eip
+
+	xor %ebp, %ebp
+	mov %esp, %eax
+	mov $_GLOBAL_OFFSET_TABLE_, %ebx
+
+	sub $8, %esp
+	pushl %eax
+	pushl $main
+	call __mlibc_entry
+	ud2
+
+	.cfi_endproc
+.size _start, . - _start
+
+.section .note.GNU-stack,"",@progbits
diff --git a/sysdeps/andromeda/crt/crti.S b/sysdeps/andromeda/crt/crti.S
new file mode 100644
index 00000000..47f6d64f
--- /dev/null
+++ b/sysdeps/andromeda/crt/crti.S
@@ -0,0 +1,20 @@
+.section ".init", "ax", @progbits
+
+.globl _init
+.hidden _init
+.type _init, @function
+_init:
+	push %ebp
+	mov %esp, %ebp
+
+.section ".fini", "ax", @progbits
+
+.globl _fini
+.hidden _fini
+.type _fini, @function
+_fini:
+	push %ebp
+	mov %esp, %ebp
+
+.section .note.GNU-stack,"",@progbits
+
diff --git a/sysdeps/andromeda/crt/crtn.S b/sysdeps/andromeda/crt/crtn.S
new file mode 100644
index 00000000..3cb40b8c
--- /dev/null
+++ b/sysdeps/andromeda/crt/crtn.S
@@ -0,0 +1,12 @@
+.section ".init", "ax", @progbits
+
+	leave
+	ret
+
+.section ".fini", "ax", @progbits
+
+	leave
+	ret
+
+.section .note.GNU-stack,"",@progbits
+
diff --git a/sysdeps/andromeda/crt/meson.build b/sysdeps/andromeda/crt/meson.build
new file mode 100644
index 00000000..ae05517d
--- /dev/null
+++ b/sysdeps/andromeda/crt/meson.build
@@ -0,0 +1,13 @@
+if not headers_only
+    foreach name : ['crt0', 'crti', 'crtn', 'Scrt0']
+        custom_target(
+            name,
+            build_by_default: true,
+            command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+            input: name + '.S',
+            install: true,
+            install_dir: get_option('libdir'),
+            output: name + '.o'
+        )
+    endforeach
+endif
diff --git a/sysdeps/andromeda/generic/entry.cpp b/sysdeps/andromeda/generic/entry.cpp
new file mode 100644
index 00000000..6e28747f
--- /dev/null
+++ b/sysdeps/andromeda/generic/entry.cpp
@@ -0,0 +1,17 @@
+#include "mlibc/elf/startup.h"
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/auxv.h>
+
+extern "C" void __dlapi_enter(uintptr_t *);
+
+extern char **environ;
+
+size_t __hwcap;
+
+extern "C" [[noreturn]] void __mlibc_entry(int (*main)(int, char *[], char *[]), uintptr_t *stack) {
+    __dlapi_enter(stack);
+    __hwcap = getauxval(AT_HWCAP);
+    exit(main(mlibc::entry_stack.argc, mlibc::entry_stack.argv, environ));
+}
diff --git a/sysdeps/andromeda/generic/generic.cpp b/sysdeps/andromeda/generic/generic.cpp
new file mode 100644
index 00000000..f1547a82
--- /dev/null
+++ b/sysdeps/andromeda/generic/generic.cpp
@@ -0,0 +1,823 @@
+#include "syscall.h"
+#include <andromeda/ioctl.h>
+#include <andromeda/string.h>
+#include <andromeda/syscall.h>
+#include <errno.h>
+#include <limits.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/arch-defs.hpp>
+#include <stdlib.h>
+#include <string.h>
+
+#define STACK_SIZE 0x800000
+
+namespace mlibc {
+void sys_libc_log(const char *message) { SYSCALL2(SYS_KLOG, message, strlen(message)); }
+
+int sys_anon_allocate(size_t size, void **pointer) {
+	return sys_vm_map(
+	    NULL, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0, pointer
+	);
+}
+
+int sys_anon_free(void *pointer, size_t size) { return sys_vm_unmap(pointer, size); }
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
+	if (flags & 0xf0000000) {
+		return EINVAL;
+	}
+
+	if (prot & ~0xf) {
+		return EINVAL;
+	}
+
+	*window = (void *)SYSCALL(
+	              6,
+	              SYS_MMAP,
+	              hint,
+	              size,
+	              (prot << 28) | flags,
+	              fd,
+	              (unsigned long)offset,
+	              (unsigned long)(offset >> 32)
+	)
+	              .r2;
+	return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size) {
+	SYSCALL(2, SYS_MUNMAP, pointer, size);
+	return 0;
+}
+
+void sys_libc_panic() {
+	sys_kill(sys_getpid(), SIGABRT);
+	__builtin_trap();
+}
+
+int sys_tcb_set(void *pointer) {
+	SYSCALL(1, SYS_SET_TCB, pointer);
+	return 0;
+}
+
+int sys_futex_wake(int *pointer) {
+	SYSCALL(1, SYS_FUTEX_WAKE, pointer);
+	return 0;
+}
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+	SYSCALL(
+	    5,
+	    SYS_FUTEX_WAIT,
+	    pointer,
+	    expected,
+	    (unsigned long)time->tv_sec,
+	    (unsigned long)(time->tv_sec >> 32),
+	    time->tv_nsec
+	);
+	return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+	unsigned long low = offset;
+	unsigned long high = offset >> 32;
+
+	syscall_result_t result = SYSCALL(4, SYS_SEEK, fd, low, high, whence);
+	*new_offset = ((off_t)result.r1 << 32) | result.r2;
+	return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+	*bytes_read = SYSCALL(3, SYS_READ, fd, buf, count).r1;
+	return 0;
+}
+
+int sys_close(int fd) {
+	SYSCALL(1, SYS_CLOSE, fd);
+	return 0;
+}
+
+int sys_open(const char *pathname, int flags, mode_t mode, int *fd) {
+	return sys_openat(AT_FDCWD, pathname, flags, mode, fd);
+}
+
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
+	*fd = SYSCALL(5, SYS_OPEN, dirfd, path, strlen(path), flags, mode).r1;
+	return 0;
+}
+
+int sys_clock_get(int clock, time_t *secs, long *nanos) {
+	syscall_result_t result = SYSCALL(1, SYS_CLOCK_GET, clock);
+
+	*secs = result.r2;
+	*nanos = result.r1;
+	return 0;
+}
+
+void sys_exit(int status) {
+	SYSCALL1(SYS_EXIT, status);
+	__builtin_unreachable();
+}
+
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+	*bytes_written = SYSCALL(3, SYS_WRITE, fd, buf, count).r1;
+	return 0;
+}
+
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
+	*result = SYSCALL(3, SYS_IOCTL, fd, request, arg).r1;
+	return 0;
+}
+
+int sys_isatty(int fd) {
+	struct winsize sz;
+	int result;
+	return sys_ioctl(fd, TIOCGWINSZ, &sz, &result);
+}
+
+int sys_fcntl(int fd, int request, va_list args, int *result) {
+	*result = SYSCALL(3, SYS_FCNTL, fd, request, va_arg(args, uintptr_t)).r1;
+	return 0;
+}
+
+int sys_dup(int fd, int flags, int *new_fd) {
+	*new_fd = SYSCALL(2, SYS_DUP, fd, flags).r1;
+	return 0;
+}
+
+int sys_dup2(int fd, int flags, int new_fd) {
+	SYSCALL(3, SYS_DUP2, fd, flags, new_fd);
+	return 0;
+}
+
+uid_t sys_getuid() { return SYSCALL0(SYS_GETUID).r1; }
+
+gid_t sys_getgid() { return SYSCALL0(SYS_GETGID).r1; }
+
+uid_t sys_geteuid() { return SYSCALL0(SYS_GETEUID).r1; }
+
+gid_t sys_getegid() { return SYSCALL0(SYS_GETEGID).r1; }
+
+pid_t sys_getpid() { return SYSCALL0(SYS_GETPID).r1; }
+
+pid_t sys_getppid() { return SYSCALL0(SYS_GETPPID).r1; }
+
+int sys_getpgid(pid_t pid, pid_t *pgid) {
+	*pgid = SYSCALL(1, SYS_GETPGID, pid).r1;
+	return 0;
+}
+
+static int do_fstat(int fd, const char *path, int flags, struct stat *statbuf) {
+	SYSCALL(5, SYS_STAT, fd, path, strlen(path), flags, statbuf);
+	return 0;
+}
+
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
+	switch (fsfdt) {
+		case fsfd_target::path:
+			return do_fstat(AT_FDCWD, path, flags, statbuf);
+		case fsfd_target::fd:
+			SYSCALL(2, SYS_FSTAT, fd, statbuf);
+			return 0;
+		case fsfd_target::fd_path:
+			return do_fstat(fd, path, flags, statbuf);
+		default:
+			return EINVAL;
+	}
+}
+
+int sys_pselect(
+    int nfds,
+    fd_set *readfds,
+    fd_set *writefds,
+    fd_set *errorfds,
+    const struct timespec *timeout,
+    const sigset_t *sigmask,
+    int *num_events
+) {
+	*num_events = SYSCALL(6, SYS_PSELECT, nfds, readfds, writefds, errorfds, timeout, sigmask).r1;
+	return 0;
+}
+
+int sys_sigprocmask(int how, const sigset_t *set, sigset_t *retrieve) {
+	SYSCALL(3, SYS_SIGPROCMASK, how, set, retrieve);
+	return 0;
+}
+
+[[gnu::naked]] static void default_sa_restorer(void) {
+	asm("mov %0, %%eax \n\t"
+	    "int $0x20" ::"i"(SYS_SIGRETURN));
+}
+
+int sys_sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {
+	struct sigaction sa;
+
+	if (act && !(act->sa_flags & SA_RESTORER)) {
+		sa = *act;
+		sa.sa_restorer = default_sa_restorer;
+		act = &sa;
+	}
+
+	SYSCALL(3, SYS_SIGACTION, sig, act, oact);
+	return 0;
+}
+
+int sys_access(const char *path, int mode) { return sys_faccessat(AT_FDCWD, path, mode, 0); }
+
+int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
+	SYSCALL(5, SYS_ACCESS, dirfd, pathname, strlen(pathname), mode, flags);
+	return 0;
+}
+
+int sys_fork(pid_t *child) {
+	*child = SYSCALL(0, SYS_FORK).r1;
+	return 0;
+}
+
+struct FileDescriptor {
+	int fd;
+
+	FileDescriptor(int fd) : fd(fd) {}
+
+	~FileDescriptor() { sys_close(fd); }
+};
+
+int sys_execve(const char *path, char *const *argv, char *const *envp) {
+	int fd;
+	int error = sys_open(path, O_RDONLY | O_CLOEXEC, 0, &fd);
+	if (__builtin_expect(!!error, 0))
+		return error;
+	FileDescriptor _(fd);
+
+	size_t nargv = 0;
+	while (argv[nargv]) {
+		nargv++;
+	}
+
+	size_t nenvp = 0;
+	while (envp[nenvp]) {
+		nenvp++;
+	}
+
+	auto *arg = reinterpret_cast<andromeda_tagged_string_t *>(
+	    __builtin_alloca(nargv * sizeof(andromeda_tagged_string_t))
+	);
+	auto *env = reinterpret_cast<andromeda_tagged_string_t *>(
+	    __builtin_alloca(nenvp * sizeof(andromeda_tagged_string_t))
+	);
+
+	for (size_t i = 0; i < nargv; i++) {
+		arg[i].data = argv[i];
+		arg[i].length = strlen(argv[i]);
+	}
+
+	for (size_t i = 0; i < nenvp; i++) {
+		env[i].data = envp[i];
+		env[i].length = strlen(envp[i]);
+	}
+
+	SYSCALL(5, SYS_EXEC, fd, arg, nargv, env, nenvp);
+	return 0;
+}
+
+int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *, pid_t *ret_pid) {
+	if (flags & ~(WCONTINUED | WNOHANG | WUNTRACED))
+		return EINVAL;
+
+	flags |= WEXITED;
+
+	if (flags & WUNTRACED) {
+		flags &= ~WUNTRACED;
+		flags |= WSTOPPED;
+	}
+
+	siginfo_t info;
+	*ret_pid = SYSCALL(3, SYS_PWAIT, pid, flags, &info).r1;
+
+	switch (info.si_code) {
+		case CLD_EXITED:
+			*status = W_EXITCODE(info.si_status & 0xff, 0);
+			break;
+		case CLD_KILLED:
+			*status = info.si_status & 0x7f;
+			break;
+		case CLD_DUMPED:
+			*status = (info.si_status & 0x7f) | 0x80;
+			break;
+		case CLD_STOPPED:
+			*status = W_EXITCODE(info.si_status & 0x7f, 0x7f);
+			break;
+		case CLD_CONTINUED:
+			*status = 0xffff;
+			break;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+
+int sys_waitid(idtype_t idtype, id_t id, siginfo_t *info, int options) {
+	pid_t pid;
+
+	switch (idtype) {
+		case P_PID:
+			if (id < 1 || id > INT_MAX) {
+				return EINVAL;
+			}
+
+			pid = (pid_t)id;
+			break;
+		case P_PGID:
+			if (id < 2 || id > INT_MAX) {
+				return EINVAL;
+			}
+
+			pid = -(pid_t)id;
+			break;
+		case P_ALL:
+			pid = -1;
+			break;
+		default:
+			return EINVAL;
+	}
+
+	SYSCALL(3, SYS_PWAIT, pid, options, info);
+	return 0;
+}
+
+int sys_kill(int pid, int sig) {
+	SYSCALL(2, SYS_KILL, pid, sig);
+	return 0;
+}
+
+int sys_tcgetattr(int fd, struct termios *attr) {
+	SYSCALL(3, SYS_IOCTL, fd, TCGETS, attr);
+	return 0;
+}
+
+int sys_tcsetattr(int fd, int optional_actions, const struct termios *attr) {
+	int ioctl;
+
+	switch (optional_actions) {
+		case TCSANOW:
+			ioctl = TCSETS;
+			break;
+		case TCSADRAIN:
+			ioctl = TCSETSW;
+			break;
+		case TCSAFLUSH:
+			ioctl = TCSETSF;
+			break;
+		default:
+			return EINVAL;
+	}
+
+	SYSCALL(3, SYS_IOCTL, fd, ioctl, attr);
+	return 0;
+}
+
+int sys_setpgid(pid_t pid, pid_t pgid) {
+	SYSCALL(2, SYS_SETPGID, pid, pgid);
+	return 0;
+}
+
+static int chdir_like(int syscall, const char *path) {
+	int fd;
+	int error = sys_open(path, O_PATH | O_CLOEXEC, 0, &fd);
+	if (__builtin_expect(!!error, 0)) {
+		return error;
+	}
+	FileDescriptor _(fd);
+
+	SYSCALL(1, syscall, fd);
+	return 0;
+}
+
+int sys_chdir(const char *path) { return chdir_like(SYS_CHDIR, path); }
+
+int sys_chroot(const char *path) { return chdir_like(SYS_CHROOT, path); }
+
+int sys_getcwd(char *buffer, size_t size) {
+	if (size == 0) {
+		return ERANGE;
+	}
+
+	size_t len = SYSCALL(2, SYS_GETCWD, buffer, size - 1).r1;
+	if (len >= size) {
+		return ERANGE;
+	}
+
+	buffer[len] = 0;
+	return 0;
+}
+
+int sys_open_dir(const char *path, int *handle) {
+	return sys_open(path, O_DIRECTORY | O_CLOEXEC, 0, handle);
+}
+
+int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) {
+	*bytes_read = SYSCALL(3, SYS_READDIR, handle, buffer, max_size).r1;
+	return 0;
+}
+
+int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) {
+	return sys_readlinkat(AT_FDCWD, path, buffer, max_size, length);
+}
+
+int sys_readlinkat(int dirfd, const char *path, void *buffer, size_t max_size, ssize_t *length) {
+	*length =
+	    SYSCALL(5, SYS_READLINK, dirfd, path, strlen(path), buffer, max_size ? max_size - 1 : 0).r1;
+
+	if (max_size) {
+		((char *)buffer)[*length] = 0;
+		*length += 1;
+	}
+
+	return 0;
+}
+
+int sys_gethostname(char *buffer, size_t bufsize) {
+	if (!bufsize) {
+		return 0;
+	}
+
+	size_t max = bufsize - 1;
+	size_t len = SYSCALL(2, SYS_GETHOSTNAME, buffer, max).r1;
+
+	buffer[len < max ? len : max] = 0;
+	return 0;
+}
+
+int sys_sethostname(const char *buffer, size_t bufsize) {
+	SYSCALL(2, SYS_SETHOSTNAME, buffer, bufsize);
+	return 0;
+}
+
+int sys_uname(struct utsname *buf) {
+	SYSCALL(1, SYS_UNAME, buf);
+	return 0;
+}
+
+int sys_pipe(int *fds, int flags) {
+	syscall_result_t result = SYSCALL(1, SYS_PIPE, flags);
+	fds[0] = result.r1;
+	fds[1] = result.r2;
+	return 0;
+}
+
+int sys_pread(int fd, void *buf, size_t n, off_t off, ssize_t *bytes_read) {
+	*bytes_read =
+	    SYSCALL(5, SYS_PREAD, fd, buf, n, (unsigned long)off, (unsigned long)(off >> 32)).r1;
+	return 0;
+}
+
+int sys_pwrite(int fd, const void *buf, size_t n, off_t off, ssize_t *bytes_read) {
+	*bytes_read =
+	    SYSCALL(5, SYS_PWRITE, fd, buf, n, (unsigned long)off, (unsigned long)(off >> 32)).r1;
+	return 0;
+}
+
+int sys_rmdir(const char *path) { return sys_unlinkat(AT_FDCWD, path, AT_REMOVEDIR); }
+
+int sys_unlinkat(int dirfd, const char *path, int flags) {
+	SYSCALL(4, SYS_UNLINK, dirfd, path, strlen(path), flags);
+	return 0;
+}
+
+int sys_rename(const char *path, const char *new_path) {
+	return sys_renameat(AT_FDCWD, path, AT_FDCWD, new_path);
+}
+
+int sys_renameat(int olddirfd, const char *old_path, int newdirfd, const char *new_path) {
+	SYSCALL(
+	    6, SYS_RENAME, olddirfd, old_path, strlen(old_path), newdirfd, new_path, strlen(new_path)
+	);
+	return 0;
+}
+
+void sys_thread_exit() {
+	SYSCALL1(SYS_EXIT_THREAD, 0);
+	__builtin_unreachable();
+}
+
+int sys_vm_protect(void *pointer, size_t size, int prot) {
+	SYSCALL(3, SYS_MPROTECT, pointer, size, prot);
+	return 0;
+}
+
+int sys_prepare_stack(
+    void **stack,
+    void *entry,
+    void *user_arg,
+    [[maybe_unused]] void *tcb,
+    size_t *stack_size,
+    size_t *guard_size,
+    void **stack_base
+) {
+	void *base = *stack;
+	size_t ssize = *stack_size;
+	size_t gsize = *guard_size;
+
+	if (!ssize) {
+		ssize = STACK_SIZE;
+
+		if (base) {
+			return EINVAL;
+		}
+	}
+
+	gsize = (gsize + (page_size - 1)) & ~(page_size - 1);
+	ssize = (ssize + (page_size - 1)) & ~(page_size - 1);
+
+	if (!base) {
+		void *guard;
+
+		if (int e = sys_vm_map(
+		        nullptr, ssize + gsize, PROT_NONE, MAP_ANON | MAP_PRIVATE, -1, 0, &guard
+		    )) {
+			return e;
+		}
+
+		base = reinterpret_cast<void *>(reinterpret_cast<char *>(guard) + gsize);
+
+		if (int e = sys_vm_protect(base, ssize, PROT_READ | PROT_WRITE)) {
+			sys_vm_unmap(guard, ssize + gsize);
+			return e;
+		}
+	} else {
+		gsize = 0;
+	}
+
+	*stack_size = ssize;
+	*guard_size = gsize;
+	*stack_base = base;
+
+	// -20 to ensure the stack is aligned to 16 bytes on entry
+	auto sp = reinterpret_cast<void **>(reinterpret_cast<char *>(base) + (ssize - 20));
+	sp[0] = nullptr;
+	sp[1] = user_arg;
+	sp[2] = entry;
+	*stack = sp;
+	return 0;
+}
+
+[[noreturn]] static void thread_entry(void (*func)(void *), void *ctx) {
+	func(ctx);
+	sys_thread_exit();
+}
+
+int sys_clone(void *tcb, pid_t *pid_out, void *stack) {
+	*pid_out = SYSCALL(3, SYS_CREATE_THREAD, thread_entry, tcb, stack).r1;
+	return 0;
+}
+
+int sys_mkdir(const char *path, mode_t mode) { return sys_mkdirat(AT_FDCWD, path, mode); }
+
+int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
+	return sys_mknodat(dirfd, path, (mode & ~S_IFMT) | S_IFDIR, 0);
+}
+
+int sys_mkfifoat(int dirfd, const char *path, mode_t mode) {
+	return sys_mknodat(dirfd, path, (mode & ~S_IFMT) | S_IFIFO, 0);
+}
+
+int sys_mknodat(int dirfd, const char *path, int mode, int dev) {
+	SYSCALL(5, SYS_MKNOD, dirfd, path, strlen(path), mode, dev);
+	return 0;
+}
+
+int sys_statvfs(const char *path, struct statvfs *out) {
+	SYSCALL(4, SYS_STATVFS, AT_FDCWD, path, strlen(path), out);
+	return 0;
+}
+
+int sys_fstatvfs(int fd, struct statvfs *out) {
+	SYSCALL(2, SYS_FSTATVFS, fd, out);
+	return 0;
+}
+
+int sys_ftruncate(int fd, off_t size) {
+	SYSCALL(3, SYS_FTRUNCATE, fd, (unsigned long)size, (unsigned long)(size >> 32));
+	return 0;
+}
+
+pid_t sys_gettid() { return SYSCALL0(SYS_GETTID).r1; }
+
+int sys_getsid(pid_t pid, pid_t *sid) {
+	*sid = SYSCALL(1, SYS_GETSID, pid).r1;
+	return 0;
+}
+
+int sys_getgroups(size_t size, gid_t *list, int *ret) {
+	*ret = SYSCALL(2, SYS_GETGROUPS, list, size).r1;
+	return 0;
+}
+
+void sys_yield() { SYSCALL0(SYS_YIELD); }
+
+int sys_fchdir(int fd) {
+	SYSCALL(1, SYS_CHDIR, fd);
+	return 0;
+}
+
+int sys_link(const char *old_path, const char *new_path) {
+	return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
+}
+
+int sys_linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags) {
+	andromeda_tagged_string_t link_name = {new_path, strlen(new_path)};
+	SYSCALL(6, SYS_LINK, olddirfd, old_path, strlen(old_path), newdirfd, &link_name, flags);
+	return 0;
+}
+
+int sys_symlink(const char *target_path, const char *link_path) {
+	return sys_symlinkat(target_path, AT_FDCWD, link_path);
+}
+
+int sys_symlinkat(const char *target_path, int dirfd, const char *link_path) {
+	SYSCALL(5, SYS_SYMLINK, dirfd, link_path, strlen(link_path), target_path, strlen(target_path));
+	return 0;
+}
+
+// POSIX doesn't require ttyname to error if fd is invalid or not a tty,
+// so this can be implemented entirely in userspace
+int sys_ttyname(int, char *buf, size_t size) {
+	if (size < 9) {
+		return ERANGE;
+	}
+
+	strcpy(buf, "/dev/tty");
+	return 0;
+}
+
+int sys_fadvise(int, off_t, off_t, int) {
+	// Not planned to be implemented
+	return 0;
+}
+
+void sys_sync() {
+	// Andromeda doesn't have read-write disk support, nor does it plan to implement it
+}
+
+int sys_fsync(int fd) {
+	// Andromeda doesn't have read-write disk support, nor does it plan to implement it.
+	// Still have to verify fd is valid, though - just fstat it.
+	struct stat buf;
+	return sys_stat(fsfd_target::fd, fd, nullptr, 0, &buf);
+}
+
+int sys_fdatasync(int fd) { return sys_fsync(fd); }
+
+int sys_chmod(const char *pathname, mode_t mode) {
+	return sys_fchmodat(AT_FDCWD, pathname, mode, 0);
+}
+
+int sys_fchmodat(int fd, const char *pathname, mode_t mode, int flags) {
+	SYSCALL(5, SYS_CHMOD, fd, pathname, strlen(pathname), mode, flags);
+	return 0;
+}
+
+int sys_fchmod(int fd, mode_t mode) {
+	SYSCALL(2, SYS_FCHMOD, fd, mode);
+	return 0;
+}
+
+int sys_setsid(pid_t *sid) {
+	*sid = SYSCALL(0, SYS_SETSID).r1;
+	return 0;
+}
+
+int sys_tcflow(int fd, int action) {
+	int result;
+	return sys_ioctl(fd, TCXONC, reinterpret_cast<void *>(action), &result);
+}
+
+int sys_tcflush(int fd, int queue) {
+	int result;
+	return sys_ioctl(fd, TCFLSH, reinterpret_cast<void *>(queue), &result);
+}
+
+int sys_tcdrain(int fd) {
+	int result;
+	return sys_ioctl(fd, TCSBRK, reinterpret_cast<void *>(1), &result);
+}
+
+static int do_poll(
+    struct pollfd *fds,
+    nfds_t count,
+    const struct timespec *timeout,
+    const sigset_t *sigmask,
+    int *num_events
+) {
+	*num_events = SYSCALL(4, SYS_POLL, fds, count, timeout, sigmask).r1;
+	return 0;
+}
+
+int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
+	if (timeout >= 0) {
+		struct timespec spec = {.tv_sec = timeout, .tv_nsec = 0};
+		return do_poll(fds, count, &spec, nullptr, num_events);
+	} else {
+		return do_poll(fds, count, nullptr, nullptr, num_events);
+	}
+}
+
+int sys_umask(mode_t mode, mode_t *old) {
+	*old = SYSCALL(1, SYS_UMASK, mode).r1;
+	return 0;
+}
+
+int sys_tgkill(int tgid, int tid, int sig) {
+	SYSCALL(3, SYS_TGKILL, tgid, tid, sig);
+	return 0;
+}
+
+int sys_fchownat(int dirfd, const char *pathname, uid_t owner, gid_t group, int flags) {
+	SYSCALL(6, SYS_CHOWN, dirfd, pathname, strlen(pathname), owner, group, flags);
+	return 0;
+}
+
+int sys_sigaltstack(const stack_t *ss, stack_t *oss) {
+	SYSCALL(2, SYS_SIGALTSTACK, ss, oss);
+	return 0;
+}
+
+int sys_sigsuspend(const sigset_t *set) {
+	SYSCALL(1, SYS_SIGSUSPEND, set);
+	return 0;
+}
+
+int sys_sigpending(sigset_t *set) {
+	SYSCALL(1, SYS_SIGPENDING, set);
+	return 0;
+}
+
+int sys_setgroups(size_t size, const gid_t *list) {
+	SYSCALL(2, SYS_SETGROUPS, list, size);
+	return 0;
+}
+
+int sys_pause() {
+	SYSCALL(0, SYS_PAUSE);
+	return 0;
+}
+
+int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid) {
+	SYSCALL(3, SYS_SETRESUID, ruid, euid, suid);
+	return 0;
+}
+
+int sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid) {
+	SYSCALL(3, SYS_SETRESGID, rgid, egid, sgid);
+	return 0;
+}
+
+int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid) {
+	uid_t ids[3];
+	SYSCALL(1, SYS_GETRESUID, ids);
+	*ruid = ids[0];
+	*euid = ids[1];
+	*suid = ids[2];
+	return 0;
+}
+
+int sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid) {
+	gid_t ids[3];
+	SYSCALL(1, SYS_GETRESGID, ids);
+	*rgid = ids[0];
+	*egid = ids[1];
+	*sgid = ids[2];
+	return 0;
+}
+
+int sys_setreuid(uid_t ruid, uid_t euid) {
+	SYSCALL(2, SYS_SETREUID, ruid, euid);
+	return 0;
+}
+
+int sys_setregid(gid_t rgid, gid_t egid) {
+	SYSCALL(2, SYS_SETREGID, rgid, egid);
+	return 0;
+}
+
+int sys_setuid(uid_t uid) {
+	SYSCALL(1, SYS_SETUID, uid);
+	return 0;
+}
+
+int sys_seteuid(uid_t euid) {
+	SYSCALL(1, SYS_SETEUID, euid);
+	return 0;
+}
+
+int sys_setgid(gid_t gid) {
+	SYSCALL(1, SYS_SETGID, gid);
+	return 0;
+}
+
+int sys_setegid(gid_t egid) {
+	SYSCALL(1, SYS_SETEGID, egid);
+	return 0;
+}
+}; // namespace mlibc
diff --git a/sysdeps/andromeda/generic/meson.build b/sysdeps/andromeda/generic/meson.build
new file mode 100644
index 00000000..9f0d870d
--- /dev/null
+++ b/sysdeps/andromeda/generic/meson.build
@@ -0,0 +1,2 @@
+rtld_sources += files('generic.cpp')
+libc_sources += files('entry.cpp', 'generic.cpp', 'mntent.cpp', 'mount.cpp')
diff --git a/sysdeps/andromeda/generic/mntent.cpp b/sysdeps/andromeda/generic/mntent.cpp
new file mode 100644
index 00000000..edbd96ee
--- /dev/null
+++ b/sysdeps/andromeda/generic/mntent.cpp
@@ -0,0 +1,164 @@
+#include <mlibc/allocator.hpp>
+#include <string.h>
+#include <frg/string.hpp>
+#include <mntent.h>
+#include <stdio.h>
+
+namespace {
+static char *internal_buf;
+static size_t internal_bufsize;
+} // namespace
+
+FILE *setmntent(const char *filename, const char *type) { return fopen(filename, type); }
+
+struct mntent *getmntent(FILE *stream) {
+	static struct mntent mnt;
+	return getmntent_r(stream, &mnt, (char *)&internal_buf, 0);
+}
+
+static void escape(frg::string<MemoryAllocator> &out, const char *str) {
+	for (char c = *str; c != 0; c = *++str) {
+		switch (c) {
+			case ' ':
+			case '\t':
+			case '\n':
+                out.push_back('\\');
+                out.push_back('0' + ((c >> 6) & 7));
+                out.push_back('0' + ((c >> 3) & 7));
+                out.push_back('0' + (c & 7));
+                break;
+			case '\\':
+				out.push_back('\\');
+			// fall through
+			default:
+				out.push_back(c);
+				break;
+		}
+	}
+}
+
+int addmntent(FILE *__restrict stream, const struct mntent *__restrict mnt) {
+	if (fseek(stream, 0, SEEK_END)) {
+		return 1;
+	}
+
+	frg::string<MemoryAllocator> fsname{getAllocator()};
+	frg::string<MemoryAllocator> dir{getAllocator()};
+	frg::string<MemoryAllocator> type{getAllocator()};
+	frg::string<MemoryAllocator> opts{getAllocator()};
+
+	escape(fsname, mnt->mnt_fsname);
+	escape(dir, mnt->mnt_dir);
+	escape(type, mnt->mnt_type);
+	escape(opts, mnt->mnt_opts);
+
+	return fprintf(
+	           stream,
+	           "%s %s %s %s %d %d\n",
+	           fsname.data(),
+	           dir.data(),
+	           type.data(),
+	           opts.data(),
+	           mnt->mnt_freq,
+	           mnt->mnt_passno
+	       )
+	       < 0;
+}
+
+int endmntent(FILE *stream) {
+	if (stream) {
+		fclose(stream);
+	}
+
+	return 1;
+}
+
+static char *unescape(char *buf, int indices[2]) {
+    char *start = buf + indices[0];
+    char *end = buf + indices[1];
+
+    buf = start;
+
+    while (buf < end) {
+        char c = *buf++;
+
+        if (c == '\\') {
+            char *dest = buf;
+            c = *buf++;
+
+            if (c >= '0' && c <= '7') {
+                unsigned char val = c - '0';
+
+                while (true) {
+                    c = *buf;
+                    if (c < '0' || c > '9') break;
+                    buf++;
+                    val = (val << 3) | (c - '0');
+                }
+
+                dest[-1] = val;
+            } else if (c != '\\') {
+                buf = dest;
+                continue;
+            }
+
+            memmove(dest, buf, end - buf);
+            end -= buf - dest;
+            buf = dest;
+        }
+    }
+
+    *buf++ = 0;
+    return start;
+}
+
+// adapted from musl
+struct mntent *getmntent_r(FILE *streamp, struct mntent *mntbuf, char *buf, int size) {
+	bool internal = buf == (char *)&internal_buf;
+	int indices[8];
+
+	do {
+		if (internal) {
+			getline(&internal_buf, &internal_bufsize, streamp);
+			buf = internal_buf;
+		} else {
+			fgets(buf, size, streamp);
+		}
+
+		if (feof(streamp) || ferror(streamp)) {
+			return nullptr;
+		}
+
+		size_t length = strlen(buf);
+		if (length == 0 || buf[length - 1] != '\n') {
+			errno = ERANGE;
+			return nullptr;
+		}
+
+		for (size_t i = 0; i < sizeof(indices) / sizeof(*indices); i++) {
+			indices[i] = length;
+		}
+
+		sscanf(
+		    buf,
+		    " %n%*s%n %n%*s%n %n%*s%n %n%*s%n %d %d",
+		    &indices[0],
+		    &indices[1],
+		    &indices[2],
+		    &indices[3],
+		    &indices[4],
+		    &indices[5],
+		    &indices[6],
+		    &indices[7],
+		    &mntbuf->mnt_freq,
+		    &mntbuf->mnt_passno
+		);
+	} while (buf[indices[0]] == '#' || indices[1] == size);
+
+    mntbuf->mnt_fsname = unescape(buf, &indices[0]);
+    mntbuf->mnt_dir = unescape(buf, &indices[2]);
+    mntbuf->mnt_type = unescape(buf, &indices[4]);
+    mntbuf->mnt_opts = unescape(buf, &indices[6]);
+
+    return mntbuf;
+}
diff --git a/sysdeps/andromeda/generic/mount.cpp b/sysdeps/andromeda/generic/mount.cpp
new file mode 100644
index 00000000..c4cad915
--- /dev/null
+++ b/sysdeps/andromeda/generic/mount.cpp
@@ -0,0 +1,36 @@
+#include "syscall.h"
+#include <andromeda/mount.h>
+#include <andromeda/syscall.h>
+#include <errno.h>
+#include <stddef.h>
+#include <string.h>
+
+static int sys_mount(
+    int srcdirfd, const void *src, size_t srclen, int dirfd, const void *path, size_t length
+) {
+	SYSCALL(6, SYS_MOUNT, srcdirfd, src, srclen, dirfd, path, length);
+	return 0;
+}
+
+static int sys_umount(int dirfd, const void *path, size_t length) {
+	SYSCALL(3, SYS_UMOUNT, dirfd, path, length);
+	return 0;
+}
+
+int mount(int srcdirfd, const char *src, int dirfd, const char *path) {
+	if (int e = sys_mount(srcdirfd, src, src ? strlen(src) : 0, dirfd, path, strlen(path))) {
+		errno = e;
+		return -1;
+	}
+
+	return 0;
+}
+
+int umount(int dirfd, const char *path) {
+	if (int e = sys_umount(dirfd, path, strlen(path))) {
+		errno = e;
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/sysdeps/andromeda/generic/syscall.h b/sysdeps/andromeda/generic/syscall.h
new file mode 100644
index 00000000..e05021eb
--- /dev/null
+++ b/sysdeps/andromeda/generic/syscall.h
@@ -0,0 +1,78 @@
+#pragma once
+
+typedef struct {
+	long r1;
+	long r2;
+} syscall_result_t;
+
+#define SYSCALL0(num)                                                                              \
+	({                                                                                             \
+		syscall_result_t r;                                                                        \
+		asm volatile("int $0x20" : "=a"(r.r1), "=d"(r.r2) : "a"(num) : "memory");                  \
+		r;                                                                                         \
+	})
+
+#define SYSCALL1(num, a0)                                                                          \
+	({                                                                                             \
+		syscall_result_t r;                                                                        \
+		asm volatile("int $0x20" : "=a"(r.r1), "=d"(r.r2) : "a"(num), "b"(a0) : "memory");         \
+		r;                                                                                         \
+	})
+
+#define SYSCALL2(num, a0, a1)                                                                      \
+	({                                                                                             \
+		syscall_result_t r;                                                                        \
+		asm volatile("int $0x20"                                                                   \
+		             : "=a"(r.r1), "=d"(r.r2)                                                      \
+		             : "a"(num), "b"(a0), "c"(a1)                                                  \
+		             : "memory");                                                                  \
+		r;                                                                                         \
+	})
+
+#define SYSCALL3(num, a0, a1, a2)                                                                  \
+	({                                                                                             \
+		syscall_result_t r;                                                                        \
+		asm volatile("int $0x20"                                                                   \
+		             : "=a"(r.r1), "=d"(r.r2)                                                      \
+		             : "a"(num), "b"(a0), "c"(a1), "d"(a2)                                         \
+		             : "memory");                                                                  \
+		r;                                                                                         \
+	})
+
+#define SYSCALL4(num, a0, a1, a2, a3)                                                              \
+	({                                                                                             \
+		syscall_result_t r;                                                                        \
+		asm volatile("int $0x20"                                                                   \
+		             : "=a"(r.r1), "=d"(r.r2)                                                      \
+		             : "a"(num), "b"(a0), "c"(a1), "d"(a2), "S"(a3)                                \
+		             : "memory");                                                                  \
+		r;                                                                                         \
+	})
+
+#define SYSCALL5(num, a0, a1, a2, a3, a4)                                                          \
+	({                                                                                             \
+		syscall_result_t r;                                                                        \
+		asm volatile("int $0x20"                                                                   \
+		             : "=a"(r.r1), "=d"(r.r2)                                                      \
+		             : "a"(num), "b"(a0), "c"(a1), "d"(a2), "S"(a3), "D"(a4)                       \
+		             : "memory");                                                                  \
+		r;                                                                                         \
+	})
+
+#define SYSCALL6(num, a0, a1, a2, a3, a4, a5)                                                      \
+	({                                                                                             \
+		syscall_result_t r;                                                                        \
+		asm volatile("push %%ebp; mov %[ebp], %%ebp; int $0x20; pop %%ebp"                         \
+		             : "=a"(r.r1), "=d"(r.r2)                                                      \
+		             : "a"(num), "b"(a0), "c"(a1), "d"(a2), "S"(a3), "D"(a4), [ebp] "g"(a5)        \
+		             : "memory");                                                                  \
+		r;                                                                                         \
+	})
+
+#define SYSCALL(n, vec, ...)                                                                       \
+	({                                                                                             \
+		syscall_result_t r = SYSCALL##n(vec, ##__VA_ARGS__);                                       \
+		if (__builtin_expect(r.r1 < 0, 0))                                                         \
+			return -r.r1;                                                                          \
+		r;                                                                                         \
+	})
diff --git a/sysdeps/andromeda/include/abi-bits/access.h b/sysdeps/andromeda/include/abi-bits/access.h
new file mode 120000
index 00000000..cb839316
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/access.h
@@ -0,0 +1 @@
+../../../../abis/linux/access.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/auxv.h b/sysdeps/andromeda/include/abi-bits/auxv.h
new file mode 120000
index 00000000..c43f8786
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/linux/auxv.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/blkcnt_t.h b/sysdeps/andromeda/include/abi-bits/blkcnt_t.h
new file mode 120000
index 00000000..0b0ec270
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/blksize_t.h b/sysdeps/andromeda/include/abi-bits/blksize_t.h
new file mode 120000
index 00000000..7dc8d7cf
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blksize_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/clockid_t.h b/sysdeps/andromeda/include/abi-bits/clockid_t.h
new file mode 120000
index 00000000..6a42da56
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/clockid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/clockid_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/dev_t.h b/sysdeps/andromeda/include/abi-bits/dev_t.h
new file mode 120000
index 00000000..bca881e9
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/dev_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/epoll.h b/sysdeps/andromeda/include/abi-bits/epoll.h
new file mode 100644
index 00000000..ebfcda51
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/epoll.h
@@ -0,0 +1,12 @@
+#ifndef _ABIBITS_EPOLL_H
+#define _ABIBITS_EPOLL_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "<sys/epoll.h> is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#define EPOLL_CLOEXEC 02000000 /* Same as __MLIBC_O_CLOEXEC */
+
+#endif /* _ABIBITS_EPOLL_H */
diff --git a/sysdeps/andromeda/include/abi-bits/errno.h b/sysdeps/andromeda/include/abi-bits/errno.h
new file mode 120000
index 00000000..6e507def
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/linux/errno.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/fcntl.h b/sysdeps/andromeda/include/abi-bits/fcntl.h
new file mode 120000
index 00000000..463e2c95
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/linux/fcntl.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/fsblkcnt_t.h b/sysdeps/andromeda/include/abi-bits/fsblkcnt_t.h
new file mode 120000
index 00000000..898dfb2f
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/fsblkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsblkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/fsfilcnt_t.h b/sysdeps/andromeda/include/abi-bits/fsfilcnt_t.h
new file mode 120000
index 00000000..791755c9
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/fsfilcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsfilcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/gid_t.h b/sysdeps/andromeda/include/abi-bits/gid_t.h
new file mode 120000
index 00000000..abce6d69
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/gid_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/in.h b/sysdeps/andromeda/include/abi-bits/in.h
new file mode 120000
index 00000000..418d1d5c
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/linux/in.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/ino_t.h b/sysdeps/andromeda/include/abi-bits/ino_t.h
new file mode 120000
index 00000000..4c20aca2
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/ino_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/inotify.h b/sysdeps/andromeda/include/abi-bits/inotify.h
new file mode 120000
index 00000000..b5cb2823
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/inotify.h
@@ -0,0 +1 @@
+../../../../abis/linux/inotify.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/ioctls.h b/sysdeps/andromeda/include/abi-bits/ioctls.h
new file mode 120000
index 00000000..595106b6
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/ioctls.h
@@ -0,0 +1 @@
+../../../../abis/linux/ioctls.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/ipc.h b/sysdeps/andromeda/include/abi-bits/ipc.h
new file mode 120000
index 00000000..2c7ffc4c
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/ipc.h
@@ -0,0 +1 @@
+../../../../abis/linux/ipc.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/limits.h b/sysdeps/andromeda/include/abi-bits/limits.h
new file mode 120000
index 00000000..6c88db2e
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/linux/limits.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/mode_t.h b/sysdeps/andromeda/include/abi-bits/mode_t.h
new file mode 120000
index 00000000..5d78fdfc
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/mode_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/mqueue.h b/sysdeps/andromeda/include/abi-bits/mqueue.h
new file mode 120000
index 00000000..fa87b078
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/mqueue.h
@@ -0,0 +1 @@
+../../../../abis/linux/mqueue.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/msg.h b/sysdeps/andromeda/include/abi-bits/msg.h
new file mode 120000
index 00000000..f402b493
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/msg.h
@@ -0,0 +1 @@
+../../../../abis/linux/msg.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/nlink_t.h b/sysdeps/andromeda/include/abi-bits/nlink_t.h
new file mode 120000
index 00000000..bb3b625c
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/nlink_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/packet.h b/sysdeps/andromeda/include/abi-bits/packet.h
new file mode 120000
index 00000000..998ef1ab
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/packet.h
@@ -0,0 +1 @@
+../../../../abis/linux/packet.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/pid_t.h b/sysdeps/andromeda/include/abi-bits/pid_t.h
new file mode 120000
index 00000000..baa90f6a
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/pid_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/poll.h b/sysdeps/andromeda/include/abi-bits/poll.h
new file mode 120000
index 00000000..8ea6a0a3
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/poll.h
@@ -0,0 +1 @@
+../../../../abis/linux/poll.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/ptrace.h b/sysdeps/andromeda/include/abi-bits/ptrace.h
new file mode 120000
index 00000000..b2517b2c
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/ptrace.h
@@ -0,0 +1 @@
+../../../../abis/linux/ptrace.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/random.h b/sysdeps/andromeda/include/abi-bits/random.h
new file mode 120000
index 00000000..83fc3d96
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/random.h
@@ -0,0 +1 @@
+../../../../abis/linux/random.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/reboot.h b/sysdeps/andromeda/include/abi-bits/reboot.h
new file mode 120000
index 00000000..77013a41
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/linux/reboot.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/resource.h b/sysdeps/andromeda/include/abi-bits/resource.h
new file mode 120000
index 00000000..88d74025
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/resource.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/rlim_t.h b/sysdeps/andromeda/include/abi-bits/rlim_t.h
new file mode 120000
index 00000000..e92eb5fb
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/rlim_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/rlim_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/seek-whence.h b/sysdeps/andromeda/include/abi-bits/seek-whence.h
new file mode 120000
index 00000000..df7bccf0
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/linux/seek-whence.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/shm.h b/sysdeps/andromeda/include/abi-bits/shm.h
new file mode 120000
index 00000000..067d8c4f
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/shm.h
@@ -0,0 +1 @@
+../../../../abis/linux/shm.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/sigevent.h b/sysdeps/andromeda/include/abi-bits/sigevent.h
new file mode 120000
index 00000000..83d069b5
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/sigevent.h
@@ -0,0 +1 @@
+../../../../abis/linux/sigevent.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/signal.h b/sysdeps/andromeda/include/abi-bits/signal.h
new file mode 100644
index 00000000..1687ec4e
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/signal.h
@@ -0,0 +1,537 @@
+#ifndef _ABIBITS_SIGNAL_H
+#define _ABIBITS_SIGNAL_H
+
+#include <stdint.h>
+#include <time.h>
+#include <abi-bits/sigevent.h>
+#include <abi-bits/pid_t.h>
+#include <abi-bits/uid_t.h>
+#include <bits/size_t.h>
+
+#define POLL_IN 1
+#define POLL_OUT 2
+#define POLL_MSG 3
+#define POLL_ERR 4
+#define POLL_PRI 5
+#define POLL_HUP 6
+
+typedef struct {
+	int si_signo;
+	int si_code;
+	int si_errno;
+	pid_t si_pid;
+	uid_t si_uid;
+	void *si_addr;
+	int si_status;
+	long si_band;
+	union sigval si_value;
+} siginfo_t;
+
+/* Required for sys_sigaction sysdep. */
+#define SA_NOCLDSTOP 1
+#define SA_NOCLDWAIT 2
+#define SA_SIGINFO 4
+#define SA_ONSTACK 0x08000000
+#define SA_RESTART 0x10000000
+#define SA_NODEFER 0x40000000
+#define SA_RESETHAND 0x80000000
+#define SA_RESTORER 0x04000000
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Argument for signal() */
+typedef void (*__sighandler) (int);
+
+#define SIG_ERR ((__sighandler)(void *)(-1))
+#define SIG_DFL ((__sighandler)(void *)(0))
+#define SIG_IGN ((__sighandler)(void *)(1))
+
+#define SIGABRT 1
+#define SIGALRM 2
+#define SIGBUS 3
+#define SIGCHLD 4
+#define SIGCONT 5
+#define SIGFPE 6
+#define SIGHUP 7
+#define SIGILL 8
+#define SIGINT 9
+#define SIGKILL 10
+#define SIGPIPE 11
+#define SIGQUIT 12
+#define SIGSEGV 13
+#define SIGSTOP 14
+#define SIGTERM 15
+#define SIGTSTP 16
+#define SIGTTIN 17
+#define SIGTTOU 18
+#define SIGUSR1 19
+#define SIGUSR2 20
+#define SIGPOLL 21
+#define SIGPROF 22
+#define SIGSYS 23
+#define SIGTRAP 24
+#define SIGURG 25
+#define SIGVTALRM 26
+#define SIGXCPU 27
+#define SIGXFSZ 28
+#define SIGIO 29
+#define SIGPWR 30
+#define SIGWINCH 31
+#define SIGCANCEL 32
+
+#define NSIG 33
+
+typedef struct {
+	unsigned long sig[64 / (8 * sizeof(long))];
+} sigset_t;
+
+/* constants for sigprocmask() */
+#define SIG_BLOCK 0
+#define SIG_UNBLOCK 1
+#define SIG_SETMASK 2
+
+#define MINSIGSTKSZ 2048
+#define SIGSTKSZ 8192
+#define SS_ONSTACK 1
+#define SS_DISABLE 2
+
+typedef struct __stack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+/* constants for sigev_notify of struct sigevent */
+#define SIGEV_SIGNAL 0
+#define SIGEV_NONE 1
+#define SIGEV_THREAD 2
+#define SIGEV_THREAD_ID 4
+
+#define SEGV_MAPERR 1
+#define SEGV_ACCERR 2
+
+#define BUS_ADRALN 1
+#define BUS_ADRERR 2
+#define BUS_OBJERR 3
+#define BUS_MCEERR_AR 4
+#define BUS_MCEERR_AO 5
+
+#define ILL_ILLOPC 1
+#define ILL_ILLOPN 2
+#define ILL_ILLADR 3
+#define ILL_ILLTRP 4
+#define ILL_PRVOPC 5
+#define ILL_PRVREG 6
+#define ILL_COPROC 7
+#define ILL_BADSTK 8
+#define ILL_BADIADDR 9
+
+#define SI_ASYNCNL (-60)
+#define SI_TKILL (-6)
+#define SI_SIGIO (-5)
+#define SI_ASYNCIO (-4)
+#define SI_MESGQ (-3)
+#define SI_TIMER (-2)
+#define SI_QUEUE (-1)
+#define SI_USER 0
+#define SI_KERNEL 128
+
+#if defined(__i386__)
+#define REG_GS 0
+#define REG_FS 1
+#define REG_ES 2
+#define REG_DS 3
+#define REG_EDI 4
+#define REG_ESI 5
+#define REG_EBP 6
+#define REG_ESP 7
+#define REG_EBX 8
+#define REG_EDX 9
+#define REG_ECX 10
+#define REG_EAX 11
+#define REG_TRAPNO 12
+#define REG_ERR 13
+#define REG_EIP 14
+#define REG_CS 15
+#define REG_EFL 16
+#define REG_UESP 17
+#define REG_SS 18
+#define NGREG 19
+#elif defined(__x86_64__)
+#define REG_R8 0
+#define REG_R9 1
+#define REG_R10 2
+#define REG_R11 3
+#define REG_R12 4
+#define REG_R13 5
+#define REG_R14 6
+#define REG_R15 7
+#define REG_RDI 8
+#define REG_RSI 9
+#define REG_RBP 10
+#define REG_RBX 11
+#define REG_RDX 12
+#define REG_RAX 13
+#define REG_RCX 14
+#define REG_RSP 15
+#define REG_RIP 16
+#define REG_EFL 17
+#define REG_CSGSFS 18
+#define REG_ERR 19
+#define REG_TRAPNO 20
+#define REG_OLDMASK 21
+#define REG_CR2 22
+#define NGREG 23
+#endif
+
+#include <bits/threads.h>
+
+struct sigaction {
+	union {
+		void (*sa_handler)(int);
+		void (*sa_sigaction)(int, siginfo_t *, void *);
+	} __sa_handler;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+	sigset_t sa_mask;
+};
+
+#define sa_handler __sa_handler.sa_handler
+#define sa_sigaction __sa_handler.sa_sigaction
+
+/* Taken from the linux kernel headers */
+
+#if defined(__x86_64__) || defined(__i386__)
+
+struct _fpreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+};
+
+struct _fpxreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+	unsigned short padding[3];
+};
+
+struct _xmmreg {
+	uint32_t element[4];
+};
+
+struct _fpstate {
+#if defined(__x86_64__)
+	uint16_t cwd;
+	uint16_t swd;
+	uint16_t ftw;
+	uint16_t fop;
+	uint64_t rip;
+	uint64_t rdp;
+	uint32_t mxcsr;
+	uint32_t mxcr_mask;
+	struct _fpxreg _st[8];
+	struct _xmmreg _xmm[16];
+	uint32_t padding[24];
+#elif defined(__i386__)
+	uint32_t cw;
+	uint32_t sw;
+	uint32_t tag;
+	uint32_t ipoff;
+	uint32_t cssel;
+	uint32_t dataoff;
+	uint32_t datasel;
+	struct _fpreg _st[8];
+	uint16_t status;
+	uint16_t magic;
+
+	/* FXSR FPU */
+
+	uint32_t _fxsr_env[6];
+	uint32_t mxscr;
+	uint32_t reserved;
+	struct _fpxreg _fxsr_st[8];
+	struct _xmmreg _xmm[8];
+
+	uint32_t padding2[56];
+#endif
+};
+
+struct sigcontext {
+#if defined(__x86_64__)
+	unsigned long r8, r9, r10, r11, r12, r13, r14, r15;
+	unsigned long rdi, rsi, rbp, rbx, rdx, rax, rcx, rsp, rip, eflags;
+	unsigned short cs, gs, fs, __pad0;
+	unsigned long err, trapno, oldmask, cr2;
+	struct _fpstate *fpstate;
+	unsigned long __reserved1[8];
+#elif defined(__i386__)
+	unsigned short gs, __gsh, fs, __fsh, es, __esh, ds, __dsh;
+	unsigned long edi, esi, ebp, esp, ebx, edx, ecx, eax;
+	unsigned long trapno, err, eip;
+	unsigned short cs, __csh;
+	unsigned long eflags, esp_at_signal;
+	unsigned short ss, __ssh;
+	struct _fpstate *fpstate;
+	unsigned long oldmask, cr2;
+#endif
+};
+
+typedef struct {
+	unsigned long gregs[NGREG];
+	struct _fpstate *fpregs;
+	unsigned long __reserved1[8];
+} mcontext_t;
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	mcontext_t uc_mcontext;
+	sigset_t uc_sigmask;
+} ucontext_t;
+
+#elif defined(__riscv) && __riscv_xlen == 64
+/* Definitions from Linux kernel headers. */
+
+#define NGREG 32
+
+enum {
+  REG_PC = 0,
+#define REG_PC REG_PC
+  REG_RA = 1,
+#define REG_RA REG_RA
+  REG_SP = 2,
+#define REG_SP REG_SP
+  REG_TP = 4,
+#define REG_TP REG_TP
+  REG_S0 = 8,
+#define REG_S0 REG_S0
+  REG_A0 = 10
+#define REG_A0 REG_A0
+};
+
+struct __riscv_f_ext_state {
+	uint32_t f[32];
+	uint32_t fcsr;
+};
+
+struct __riscv_d_ext_state {
+	uint64_t f[32];
+	uint32_t fcsr;
+};
+
+struct __riscv_q_ext_state {
+	uint64_t f[64] __attribute__((__aligned__(16)));
+	uint32_t fcsr;
+	uint32_t reserved[3];
+};
+
+union __riscv_fp_state {
+	struct __riscv_f_ext_state f;
+	struct __riscv_d_ext_state d;
+	struct __riscv_q_ext_state q;
+};
+
+typedef unsigned long __riscv_mc_gp_state[NGREG];
+
+typedef struct sigcontext {
+	__riscv_mc_gp_state gregs;
+	union __riscv_fp_state fpregs;
+} mcontext_t;
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct ucontext	*uc_link;
+	stack_t uc_stack;
+	sigset_t uc_sigmask;
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wpedantic"
+	uint8_t __unused[1024 / 8 - sizeof(sigset_t)];
+#pragma GCC diagnostic pop
+	mcontext_t uc_mcontext;
+} ucontext_t;
+
+#elif defined (__aarch64__)
+
+#define NGREG 34
+
+typedef struct sigcontext {
+	uint64_t fault_address;
+	uint64_t regs[31];
+	uint64_t sp;
+	uint64_t pc;
+	uint64_t pstate;
+	uint8_t __reserved[4096];
+} mcontext_t;
+
+#define FPSIMD_MAGIC 0x46508001
+#define ESR_MAGIC 0x45535201
+#define EXTRA_MAGIC 0x45585401
+#define SVE_MAGIC 0x53564501
+struct _aarch64_ctx {
+	uint32_t magic;
+	uint32_t size;
+};
+struct fpsimd_context {
+	struct _aarch64_ctx head;
+	uint32_t fpsr;
+	uint32_t fpcr;
+	__uint128_t vregs[32];
+};
+struct esr_context {
+	struct _aarch64_ctx head;
+	uint64_t esr;
+};
+struct extra_context {
+	struct _aarch64_ctx head;
+	uint64_t datap;
+	uint32_t size;
+	uint32_t __reserved[3];
+};
+struct sve_context {
+	struct _aarch64_ctx head;
+	uint16_t vl;
+	uint16_t __reserved[3];
+};
+#define SVE_VQ_BYTES		16
+#define SVE_VQ_MIN		1
+#define SVE_VQ_MAX		512
+#define SVE_VL_MIN		(SVE_VQ_MIN * SVE_VQ_BYTES)
+#define SVE_VL_MAX		(SVE_VQ_MAX * SVE_VQ_BYTES)
+#define SVE_NUM_ZREGS		32
+#define SVE_NUM_PREGS		16
+#define sve_vl_valid(vl) \
+	((vl) % SVE_VQ_BYTES == 0 && (vl) >= SVE_VL_MIN && (vl) <= SVE_VL_MAX)
+#define sve_vq_from_vl(vl)	((vl) / SVE_VQ_BYTES)
+#define sve_vl_from_vq(vq)	((vq) * SVE_VQ_BYTES)
+#define SVE_SIG_ZREG_SIZE(vq)	((unsigned)(vq) * SVE_VQ_BYTES)
+#define SVE_SIG_PREG_SIZE(vq)	((unsigned)(vq) * (SVE_VQ_BYTES / 8))
+#define SVE_SIG_FFR_SIZE(vq)	SVE_SIG_PREG_SIZE(vq)
+#define SVE_SIG_REGS_OFFSET					\
+	((sizeof(struct sve_context) + (SVE_VQ_BYTES - 1))	\
+		/ SVE_VQ_BYTES * SVE_VQ_BYTES)
+#define SVE_SIG_ZREGS_OFFSET	SVE_SIG_REGS_OFFSET
+#define SVE_SIG_ZREG_OFFSET(vq, n) \
+	(SVE_SIG_ZREGS_OFFSET + SVE_SIG_ZREG_SIZE(vq) * (n))
+#define SVE_SIG_ZREGS_SIZE(vq) \
+	(SVE_SIG_ZREG_OFFSET(vq, SVE_NUM_ZREGS) - SVE_SIG_ZREGS_OFFSET)
+#define SVE_SIG_PREGS_OFFSET(vq) \
+	(SVE_SIG_ZREGS_OFFSET + SVE_SIG_ZREGS_SIZE(vq))
+#define SVE_SIG_PREG_OFFSET(vq, n) \
+	(SVE_SIG_PREGS_OFFSET(vq) + SVE_SIG_PREG_SIZE(vq) * (n))
+#define SVE_SIG_PREGS_SIZE(vq) \
+	(SVE_SIG_PREG_OFFSET(vq, SVE_NUM_PREGS) - SVE_SIG_PREGS_OFFSET(vq))
+#define SVE_SIG_FFR_OFFSET(vq) \
+	(SVE_SIG_PREGS_OFFSET(vq) + SVE_SIG_PREGS_SIZE(vq))
+#define SVE_SIG_REGS_SIZE(vq) \
+	(SVE_SIG_FFR_OFFSET(vq) + SVE_SIG_FFR_SIZE(vq) - SVE_SIG_REGS_OFFSET)
+#define SVE_SIG_CONTEXT_SIZE(vq) (SVE_SIG_REGS_OFFSET + SVE_SIG_REGS_SIZE(vq))
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	sigset_t uc_sigmask;
+	mcontext_t uc_mcontext;
+} ucontext_t;
+
+#elif defined (__m68k__)
+
+/* taken from musl */
+
+#if defined(_GNU_SOURCE) || defined(__MLIBC_BUILDING_MLIBC)
+enum { R_D0 = 0 };
+#define R_D0 R_D0
+enum { R_D1 = 1 };
+#define R_D1 R_D1
+enum { R_D2 = 2 };
+#define R_D2 R_D2
+enum { R_D3 = 3 };
+#define R_D3 R_D3
+enum { R_D4 = 4 };
+#define R_D4 R_D4
+enum { R_D5 = 5 };
+#define R_D5 R_D5
+enum { R_D6 = 6 };
+#define R_D6 R_D6
+enum { R_D7 = 7 };
+#define R_D7 R_D7
+enum { R_A0 = 8 };
+#define R_A0 R_A0
+enum { R_A1 = 9 };
+#define R_A1 R_A1
+enum { R_A2 = 10 };
+#define R_A2 R_A2
+enum { R_A3 = 11 };
+#define R_A3 R_A3
+enum { R_A4 = 12 };
+#define R_A4 R_A4
+enum { R_A5 = 13 };
+#define R_A5 R_A5
+enum { R_A6 = 14 };
+#define R_A6 R_A6
+enum { R_A7 = 15 };
+#define R_A7 R_A7
+enum { R_SP = 15 };
+#define R_SP R_SP
+enum { R_PC = 16 };
+#define R_PC R_PC
+enum { R_PS = 17 };
+#define R_PS R_PS
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(__MLIBC_BUILDING_MLIBC)
+
+struct sigcontext {
+	unsigned long sc_mask, sc_usp, sc_d0, sc_d1, sc_a0, sc_a1;
+	unsigned short sc_sr;
+	unsigned long sc_pc;
+	unsigned short sc_formatvec;
+	unsigned long sc_fpregs[6], sc_fpcntl[3];
+	unsigned char sc_fpstate[216];
+};
+
+typedef int greg_t, gregset_t[18];
+typedef struct {
+	int f_pcr, f_psr, f_fpiaddr, f_fpregs[8][3];
+} fpregset_t;
+
+typedef struct {
+	int version;
+	gregset_t gregs;
+	fpregset_t fpregs;
+} mcontext_t;
+#else
+typedef struct {
+	int __version;
+	int __gregs[18];
+	int __fpregs[27];
+} mcontext_t;
+#endif
+
+struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+};
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	mcontext_t uc_mcontext;
+	long __reserved[80];
+	sigset_t uc_sigmask;
+} ucontext_t;
+
+
+#else
+#error "Missing architecture specific code."
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_SIGNAL_H */
diff --git a/sysdeps/andromeda/include/abi-bits/sigval.h b/sysdeps/andromeda/include/abi-bits/sigval.h
new file mode 120000
index 00000000..ccd43a55
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/sigval.h
@@ -0,0 +1 @@
+../../../../abis/linux/sigval.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/socket.h b/sysdeps/andromeda/include/abi-bits/socket.h
new file mode 120000
index 00000000..f1dc016e
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/linux/socket.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/socklen_t.h b/sysdeps/andromeda/include/abi-bits/socklen_t.h
new file mode 120000
index 00000000..41f3b11f
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/socklen_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/socklen_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/stat.h b/sysdeps/andromeda/include/abi-bits/stat.h
new file mode 120000
index 00000000..1f63b41f
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/linux/stat.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/statfs.h b/sysdeps/andromeda/include/abi-bits/statfs.h
new file mode 120000
index 00000000..e3d202f5
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/statfs.h
@@ -0,0 +1 @@
+../../../../abis/linux/statfs.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/statvfs.h b/sysdeps/andromeda/include/abi-bits/statvfs.h
new file mode 100644
index 00000000..15f66b68
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/statvfs.h
@@ -0,0 +1,48 @@
+#ifndef _ABIBITS_STATVFS_H
+#define _ABIBITS_STATVFS_H
+
+#include <abi-bits/fsblkcnt_t.h>
+#include <abi-bits/fsfilcnt_t.h>
+
+#define ST_RDONLY 1
+#define ST_NOSUID 2
+#define ST_MANDLOCK 64
+
+#define FSTYPSZ 16
+
+/* On Linux, this struct is not directly used by the kernel. */
+
+/* WARNING: keep `statvfs` and `statvfs64` in sync or bad things will happen! */
+struct statvfs {
+	unsigned long f_bsize;
+	unsigned long f_frsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsfilcnt_t f_favail;
+	unsigned long f_fsid;
+    char f_basetype[FSTYPSZ];
+	unsigned long f_flag;
+	unsigned long f_namemax;
+};
+
+/* WARNING: keep `statvfs` and `statvfs64` in sync or bad things will happen! */
+struct statvfs64 {
+	unsigned long f_bsize;
+	unsigned long f_frsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsfilcnt_t f_favail;
+	unsigned long f_fsid;
+    char f_basetype[FSTYPSZ];
+	unsigned long f_flag;
+	unsigned long f_namemax;
+};
+
+#endif /* _ABIBITS_STATVFS_H */
+
diff --git a/sysdeps/andromeda/include/abi-bits/statx.h b/sysdeps/andromeda/include/abi-bits/statx.h
new file mode 120000
index 00000000..8702a1d0
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/statx.h
@@ -0,0 +1 @@
+../../../../abis/linux/statx.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/suseconds_t.h b/sysdeps/andromeda/include/abi-bits/suseconds_t.h
new file mode 120000
index 00000000..9ed65977
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/suseconds_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/suseconds_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/termios.h b/sysdeps/andromeda/include/abi-bits/termios.h
new file mode 120000
index 00000000..ee8f0b09
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/termios.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/time.h b/sysdeps/andromeda/include/abi-bits/time.h
new file mode 120000
index 00000000..2a026257
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/linux/time.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/uid_t.h b/sysdeps/andromeda/include/abi-bits/uid_t.h
new file mode 120000
index 00000000..b3067778
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/uid_t.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/utsname.h b/sysdeps/andromeda/include/abi-bits/utsname.h
new file mode 120000
index 00000000..b2857547
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/utsname.h
@@ -0,0 +1 @@
+../../../../abis/linux/utsname.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/vm-flags.h b/sysdeps/andromeda/include/abi-bits/vm-flags.h
new file mode 120000
index 00000000..bbe258cf
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/linux/vm-flags.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/vt.h b/sysdeps/andromeda/include/abi-bits/vt.h
new file mode 120000
index 00000000..5798a4ac
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/vt.h
@@ -0,0 +1 @@
+../../../../abis/linux/vt.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/wait.h b/sysdeps/andromeda/include/abi-bits/wait.h
new file mode 120000
index 00000000..feb2840c
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/linux/wait.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/abi-bits/xattr.h b/sysdeps/andromeda/include/abi-bits/xattr.h
new file mode 120000
index 00000000..66412d70
--- /dev/null
+++ b/sysdeps/andromeda/include/abi-bits/xattr.h
@@ -0,0 +1 @@
+../../../../abis/linux/xattr.h
\ No newline at end of file
diff --git a/sysdeps/andromeda/include/andromeda/cpu.h b/sysdeps/andromeda/include/andromeda/cpu.h
new file mode 100644
index 00000000..8965d465
--- /dev/null
+++ b/sysdeps/andromeda/include/andromeda/cpu.h
@@ -0,0 +1,35 @@
+#ifndef _ANDROMEDA_CPU_H
+#define _ANDROMEDA_CPU_H
+
+#include <stdint.h>
+
+typedef struct {
+    uint32_t ldt;
+    uint32_t eax;
+    uint32_t ebx;
+    uint32_t ecx;
+    uint32_t edx;
+    uint32_t esi;
+    uint32_t edi;
+    uint32_t ebp;
+    uint32_t eflags;
+    uint32_t ds;
+    uint32_t es;
+    uint32_t fs;
+    uint32_t gs;
+    uint32_t ss;
+    uint32_t esp;
+    uint32_t eip;
+    uint32_t cs;
+    struct {
+        uint16_t pad;
+        uint16_t limit;
+        uint32_t base;
+    } gdtr;
+} andromeda_cpu_regs_t;
+
+/* Note that this also disables paging, so your addresses have to be physical ones */
+#define IOCTL_SET_REGISTERS 0x20000
+#define IOCTL_REBOOT 0x20001
+
+#endif /* _ANDROMEDA_CPU_H */
diff --git a/sysdeps/andromeda/include/andromeda/ioctl.h b/sysdeps/andromeda/include/andromeda/ioctl.h
new file mode 100644
index 00000000..b63bc6c4
--- /dev/null
+++ b/sysdeps/andromeda/include/andromeda/ioctl.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#define TCGETS 0x5401
+#define TCSETS 0x5402
+#define TCSETSW 0x5403
+#define TCSETSF 0x5404
+#define TCSBRK 0x5409
+#define TCXONC 0x540a
+#define TCFLSH 0x540b
+
+#define IOCTL_GET_MODIFIER_STATE 0x30000
+#define MODIFIER_CONTROL 1
+#define MODIFIER_LEFT_SHIFT 2
+#define MODIFIER_RIGHT_SHIFT 4
+#define MODIFIER_ALT 8
+#define MODIFIER_SCROLL_LOCK 16
+#define MODIFIER_NUM_LOCK 32
+#define MODIFIER_CAPS_LOCK 64
+#define MODIFIER_INSERT 128
diff --git a/sysdeps/andromeda/include/andromeda/memory.h b/sysdeps/andromeda/include/andromeda/memory.h
new file mode 100644
index 00000000..caa8e35e
--- /dev/null
+++ b/sysdeps/andromeda/include/andromeda/memory.h
@@ -0,0 +1,16 @@
+#ifndef _ANDROMEDA_MEMORY_H
+#define _ANDROMEDA_MEMORY_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+typedef struct {
+	size_t align;
+	size_t pages;
+	uint64_t addr; /* on entry, this is the highest allowed address. changed on exit. */
+	int flags;     /* flags that should be set on the fd */
+} andromeda_pmalloc_t;
+
+#define IOCTL_PMALLOC 0x10000
+
+#endif /* _ANDROMEDA_MEMORY_H */
diff --git a/sysdeps/andromeda/include/andromeda/mount.h b/sysdeps/andromeda/include/andromeda/mount.h
new file mode 100644
index 00000000..c8b2041d
--- /dev/null
+++ b/sysdeps/andromeda/include/andromeda/mount.h
@@ -0,0 +1,15 @@
+#ifndef _ANDROMEDA_MOUNT_H
+#define _ANDROMEDA_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int mount(int srcdirfd, const char *src, int dirfd, const char *path);
+int umount(int dirfd, const char *path);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* _ANDROMEDA_MOUNT_H */
diff --git a/sysdeps/andromeda/include/andromeda/string.h b/sysdeps/andromeda/include/andromeda/string.h
new file mode 100644
index 00000000..58bac89d
--- /dev/null
+++ b/sysdeps/andromeda/include/andromeda/string.h
@@ -0,0 +1,11 @@
+#ifndef _ANDROMEDA_STRING_H
+#define _ANDROMEDA_STRING_H
+
+#include <stddef.h>
+
+typedef struct {
+    const void *data;
+    size_t length;
+} andromeda_tagged_string_t;
+
+#endif /* _ANDROMEDA_STRING_H */
diff --git a/sysdeps/andromeda/include/andromeda/syscall.h b/sysdeps/andromeda/include/andromeda/syscall.h
new file mode 100644
index 00000000..03c21367
--- /dev/null
+++ b/sysdeps/andromeda/include/andromeda/syscall.h
@@ -0,0 +1,91 @@
+#ifndef _ANDROMEDA_SYSCALL_H
+#define _ANDROMEDA_SYSCALL_H
+
+#define SYS_KLOG 0
+#define SYS_MMAP 1
+#define SYS_MUNMAP 2
+#define SYS_SET_TCB 3
+#define SYS_FUTEX_WAKE 4
+#define SYS_FUTEX_WAIT 5
+#define SYS_SEEK 6
+#define SYS_READ 7
+#define SYS_CLOSE 8
+#define SYS_OPEN 9
+#define SYS_CLOCK_GET 10
+#define SYS_EXIT 11
+#define SYS_WRITE 12
+#define SYS_IOCTL 13
+#define SYS_FCNTL 14
+#define SYS_DUP 15
+#define SYS_DUP2 16
+#define SYS_GETUID 17
+#define SYS_GETGID 18
+#define SYS_GETEUID 19
+#define SYS_GETEGID 20
+#define SYS_GETPID 21
+#define SYS_GETPPID 22
+#define SYS_GETPGID 23
+#define SYS_STAT 24
+#define SYS_FSTAT 25
+#define SYS_PSELECT 26
+#define SYS_SIGPROCMASK 27
+#define SYS_SIGACTION 28
+#define SYS_SIGRETURN 29
+#define SYS_ACCESS 30
+#define SYS_FORK 31
+#define SYS_EXEC 32
+#define SYS_PWAIT 33
+#define SYS_KILL 34
+#define SYS_SETPGID 35
+#define SYS_CHDIR 36
+#define SYS_CHROOT 37
+#define SYS_GETCWD 38
+#define SYS_READDIR 39
+#define SYS_READLINK 40
+#define SYS_GETHOSTNAME 41
+#define SYS_SETHOSTNAME 42
+#define SYS_UNAME 43
+#define SYS_PIPE 44
+#define SYS_PREAD 45
+#define SYS_PWRITE 46
+#define SYS_UNLINK 47
+#define SYS_RENAME 48
+#define SYS_EXIT_THREAD 49
+#define SYS_MPROTECT 50
+#define SYS_CREATE_THREAD 51
+#define SYS_MOUNT 52
+#define SYS_UMOUNT 53
+#define SYS_MKNOD 54
+#define SYS_STATVFS 55
+#define SYS_FSTATVFS 56
+#define SYS_FTRUNCATE 57
+#define SYS_GETTID 58
+#define SYS_GETSID 59
+#define SYS_GETGROUPS 60
+#define SYS_YIELD 61
+#define SYS_LINK 62
+#define SYS_SYMLINK 63
+#define SYS_CHMOD 64
+#define SYS_FCHMOD 65
+#define SYS_SETSID 66
+#define SYS_POLL 67
+#define SYS_UMASK 68
+#define SYS_TGKILL 69
+#define SYS_CHOWN 70
+#define SYS_SIGALTSTACK 71
+#define SYS_SIGSUSPEND 72
+#define SYS_SIGPENDING 73
+#define SYS_SETGROUPS 74
+#define SYS_PAUSE 75
+#define SYS_SETRESUID 76
+#define SYS_SETRESGID 77
+#define SYS_GETRESUID 78
+#define SYS_GETRESGID 79
+#define SYS_SETREUID 80
+#define SYS_SETREGID 81
+#define SYS_SETUID 82
+#define SYS_SETEUID 83
+#define SYS_SETGID 84
+#define SYS_SETEGID 85
+
+#endif /* _ANDROMEDA_SYSCALL_H */
diff --git a/sysdeps/andromeda/include/andromeda/video.h b/sysdeps/andromeda/include/andromeda/video.h
new file mode 100644
index 00000000..852effb5
--- /dev/null
+++ b/sysdeps/andromeda/include/andromeda/video.h
@@ -0,0 +1,51 @@
+#ifndef _ANDROMEDA_VIDEO_H
+#define _ANDROMEDA_VIDEO_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define ANDROMEDA_MEMORY_MODEL_CGA_TEXT 0
+#define ANDROMEDA_MEMORY_MODEL_RGB 1
+
+typedef struct {
+    uint64_t pitch;
+    uint32_t width;
+    uint32_t height;
+    uint8_t bits_per_pixel;
+    uint8_t memory_model;
+    union {
+        struct {
+            struct {
+                uint8_t mask_size;
+                uint8_t field_pos;
+            } red, green, blue;
+        } rgb;
+    };
+} andromeda_video_mode_t;
+
+typedef struct {
+    uint64_t address;
+    andromeda_video_mode_t mode;
+} andromeda_framebuffer_t;
+
+typedef struct {
+    andromeda_framebuffer_t framebuffer;
+    int flags;
+    int mode_index;
+} andromeda_framebuffer_request_t;
+
+typedef struct {
+    andromeda_video_mode_t *modes;
+    size_t start;
+    size_t capacity;
+} andromeda_video_modes_t;
+
+/* in: andromeda_video_modes_t * (modes list gets filled)
+ * out: total number of modes */
+#define IOCTL_LIST_MODES 0x30000
+
+/* in: andromeda_framebuffer_request_t * (framebuffer field gets filled)
+ * out: fd representing framebuffer (when the last fd gets closed, the original mode is restored) */
+#define IOCTL_SET_MODE 0x30001
+
+#endif /* _ANDROMEDA_VIDEO_H */
diff --git a/sysdeps/andromeda/include/meson.build b/sysdeps/andromeda/include/meson.build
new file mode 100644
index 00000000..f7ebf912
--- /dev/null
+++ b/sysdeps/andromeda/include/meson.build
@@ -0,0 +1,65 @@
+if not no_headers
+    install_headers(
+        'abi-bits/access.h',
+        'abi-bits/auxv.h',
+        'abi-bits/blkcnt_t.h',
+        'abi-bits/blksize_t.h',
+        'abi-bits/clockid_t.h',
+        'abi-bits/dev_t.h',
+        'abi-bits/epoll.h',
+        'abi-bits/errno.h',
+        'abi-bits/fcntl.h',
+        'abi-bits/fsblkcnt_t.h',
+        'abi-bits/fsfilcnt_t.h',
+        'abi-bits/gid_t.h',
+        'abi-bits/in.h',
+        'abi-bits/ino_t.h',
+        'abi-bits/inotify.h',
+        'abi-bits/ioctls.h',
+        'abi-bits/ipc.h',
+        'abi-bits/limits.h',
+        'abi-bits/mode_t.h',
+        'abi-bits/mqueue.h',
+        'abi-bits/msg.h',
+        'abi-bits/nlink_t.h',
+        'abi-bits/packet.h',
+        'abi-bits/pid_t.h',
+        'abi-bits/poll.h',
+        'abi-bits/ptrace.h',
+        'abi-bits/random.h',
+        'abi-bits/reboot.h',
+        'abi-bits/resource.h',
+        'abi-bits/rlim_t.h',
+        'abi-bits/seek-whence.h',
+        'abi-bits/shm.h',
+        'abi-bits/sigevent.h',
+        'abi-bits/signal.h',
+        'abi-bits/sigval.h',
+        'abi-bits/socket.h',
+        'abi-bits/socklen_t.h',
+        'abi-bits/stat.h',
+        'abi-bits/statfs.h',
+        'abi-bits/statvfs.h',
+        'abi-bits/statx.h',
+        'abi-bits/suseconds_t.h',
+        'abi-bits/termios.h',
+        'abi-bits/time.h',
+        'abi-bits/uid_t.h',
+        'abi-bits/utsname.h',
+        'abi-bits/vm-flags.h',
+        'abi-bits/vt.h',
+        'abi-bits/wait.h',
+        'abi-bits/xattr.h',
+        'andromeda/cpu.h',
+        'andromeda/ioctl.h',
+        'andromeda/memory.h',
+        'andromeda/mount.h',
+        'andromeda/string.h',
+        'andromeda/syscall.h',
+        'andromeda/video.h',
+        'sys/sysmacros.h',
+        'mntent.h',
+        follow_symlinks: true,
+        preserve_path: true,
+    )
+endif
diff --git a/sysdeps/andromeda/include/mntent.h b/sysdeps/andromeda/include/mntent.h
new file mode 100644
index 00000000..d2e49ff0
--- /dev/null
+++ b/sysdeps/andromeda/include/mntent.h
@@ -0,0 +1,43 @@
+#ifndef _MNTENT_H
+#define _MNTENT_H
+
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MOUNTED "/etc/mtab"
+
+#define MNTOPT_DEFAULTS "defaults"
+#define MNTOPT_RO "ro"
+#define MNTOPT_RW "rw"
+#define MNTOPT_SUID "suid"
+#define MNTOPT_NOSUID "nosuid"
+#define MNTOPT_NOAUTO "noauto"
+
+struct mntent {
+    char *mnt_fsname;
+    char *mnt_dir;
+    char *mnt_type;
+    char *mnt_opts;
+    int mnt_freq;
+    int mnt_passno;
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+FILE *setmntent(const char *__filename, const char *__type);
+struct mntent *getmntent(FILE *__stream);
+int addmntent(FILE *__restrict __stream, const struct mntent *__restrict __mnt);
+int endmntent(FILE *__stream);
+char *hasmntopt(const struct mntent *__mnt, const char *__opt);
+struct mntent *getmntent_r(FILE *__streamp, struct mntent *__mntbuf, char *__buf, int __size);
+
+#endif /* !defined(__MLIBC_ABI_ONLY) */
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* _MNTENT_H */
diff --git a/sysdeps/andromeda/include/sys/sysmacros.h b/sysdeps/andromeda/include/sys/sysmacros.h
new file mode 100644
index 00000000..7eacbe5e
--- /dev/null
+++ b/sysdeps/andromeda/include/sys/sysmacros.h
@@ -0,0 +1,33 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <bits/inline-definition.h>
+
+__MLIBC_INLINE_DEFINITION unsigned int __mlibc_dev_major(
+    unsigned long long int __dev) {
+return __dev >> 32;
+}
+
+__MLIBC_INLINE_DEFINITION unsigned int __mlibc_dev_minor(
+    unsigned long long int __dev) {
+return __dev;
+}
+
+__MLIBC_INLINE_DEFINITION unsigned long long int __mlibc_dev_makedev(
+    unsigned int __major, unsigned int __minor) {
+return ((unsigned long long int)__major << 32) | __minor;
+}
+
+#define major(dev) __mlibc_dev_major(dev)
+#define minor(dev) __mlibc_dev_minor(dev)
+#define makedev(major, minor) __mlibc_dev_makedev(major, minor)
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* _SYS_SYSMACROS_H */
diff --git a/sysdeps/andromeda/meson.build b/sysdeps/andromeda/meson.build
new file mode 100644
index 00000000..e8c23a71
--- /dev/null
+++ b/sysdeps/andromeda/meson.build
@@ -0,0 +1,13 @@
+sysdep_supported_options = {
+	'posix': true,
+	'linux': false,
+	'glibc': true,
+	'bsd': true,
+}
+
+rtld_include_dirs += include_directories('include')
+libc_include_dirs += include_directories('include')
+
+subdir('crt')
+subdir('include')
+subdir('generic')
-- 
2.49.0

